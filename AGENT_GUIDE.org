#+TITLE: How to write an agent for sge

* Quick Start

** Java Installation

sge is written for Java 11 which is available under [[https://jdk.java.net/][https://jdk.java.net/]]

** Engine Installation

The engine itself is bundled with all it's dependencies in a fat-jar, usually
named sge-MA.MI.P.jar or strategyGameEngine-MA.MI.P.jar and can be executed with

#+BEGIN_SRC

java -jar sge-MA.MI.P.jar

#+END_SRC


*** Synopsis

Note: A comprehensive synopsis can be viewed with the ~-h~ or ~--help~ flag.

To load a game or an agent and play a single match append the jar to the execution line.

#+BEGIN_SRC

java -jar sge-MA.MI.P.jar match jar [jars...]

#+END_SRC

The engine can determine if it is a game or an agent by itself so the order does
not matter.

** Game Installation

The game itself is only required to be called via the engine as an argument.

** Agent Installation

Agents are only required to be called via the engine as an argument.

** Writing an Agent

*** Build environment

#+TODO: Adding the dependencies over jcenter()

Through the build tool make sure that following attributes are ensured:

+ Source Compatibility: 1.11
+ Following Manifest attributes
  - 'Sge-Type': 'agent'
  - 'Agent-Class': path.to.actual.agent
  - 'Agent-Name': The name of the agent
+ Engine is in classpath
+ Recommended: Game is in classpath

To achieve this in gradle:

#+BEGIN_SRC gradle

sourceCompatibility = 1.11

dependencies {
 compile fileTree(dir: path-to-engine-and-game, include: ['*.jar'])
}

jar {
 manifest {
  attributes 'Sge-Type': 'agent'
  attributes 'Agent-Class': 'com.mydomain.firstagent.FirstAgent'
  attributes 'Agent-Name': 'FirstAgent'
 }
}

#+END_SRC

*** Implementing the GameAgent Interface

In order to write an agent for sge a class has to implement the interface
~dev.entze.sge.agent.GameAgent~. It is also highly recommended to extend from
~dev.entze.sge.agent.AbstractAgent~. It provides comparators which allow to
compare games by utility and heuristic value and a method
~shouldStopComputation()~ which checks if the a certain part (per default half)
of the computation time was already used.

Here an minimal working example for the game Risk:

#+BEGIN_SRC java

import dev.entze.sge.agent.*;
import dev.entze.sge.engine.Logger;
import dev.entze.sge.game.risk.board.*;

public class FirstAgent extends AbstractGameAgent<Risk, RiskAction>
  implements GameAgent<Risk, RiskAction> {

 public FirstAgent(Logger log){
  super(log);
 }

 @Override
 public RiskAction computeNextAction(Risk game,
                                     long computationTime,
                                     TimeUnit timeUnit){
  //optionally set AbstractGameAgent timers
  super.setTimers(computationTime, timeUnit);
  //choose the first option
  return List.copyOf(game.getPossibleActions()).get(0);
 }

}

#+END_SRC

Note that there has to exist at least a constructor with ~Logger~ as argument.
This logger does not have to be used though.

Every instance of the agents is created via this constructor. This also means
that if the same agent plays against itself two instances of it are created.

Every agent also has the methods ~setUp(numberOfPlayers, playerNumber)~ called
before every match, ~tearDown()~ called after every match, and ~destroy()~
called before shutting down. These methods can be used to get resources in place
or to destroy them. Note that the same instance is used for multiple matches.

# * Comprehensive Guide
